{% extends 'base.html' %}
{% load static %}


{% block content %}
  <!-- Tabs ÂØºËà™ -->
  <div class="shrink-0 mb-2 sticky top-[4rem] h-fit bg-base-100 rounded shadow z-10">
    <div class="tabs max-w-7xl mx-auto">
    <a href="?tab=warehouseproduct" class="tab tab-lifted text-lg transition bg-gray-200 hover:bg-gray-300 text-gray-700" data-tab="warehouseproduct">
      Warehouse
    </a>
    <a href="?tab=purchaseorders" class="tab tab-lifted text-lg transition bg-gray-200 hover:bg-gray-300 text-gray-700" data-tab="purchaseorders">
      PurchaseOrders
    </a>
  </div>
</div>


  <!-- ÂÜÖÂÆπÂå∫Âüü -->
  <div id="tab-content">
    {% if active_tab == 'purchaseorders' %}
      {% include "warehouse/purchase_orders_partial.html" %}
    {% else %}
      {% include "warehouse/warehouse_product_partial.html" %}
    {% endif %}
  </div>
{% endblock %}


{% block extra_js %}
<!-- ÂºïÂÖ• SweetAlert2 -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<script>
const TAB_SPECIFIC_PARAMS = {
    'warehouseproduct': ['warehouse', 'supplier', 'q', 'page'], // URL keys
    'purchaseorders': ['status', 'supplier', 'q', 'page']    // URL keys
};
const DEFAULT_TAB = 'warehouseproduct';

// JS state objects will now use URL-compatible keys
let pendingPOFilters = {}; // For Purchase Orders tab
window.currentWarehouseFilters = {}; // For Warehouse Product tab


//  =========================== Warehouse Tab Initializer
function initWarehouseTab() {
    const container = document.querySelector('#tab-content');
    if (!container) return;
    console.log("üöÄ initWarehouseTab (v4)");

    window.currentWarehouseFilters = {}; // Use URL keys
    const currentUrlParams = new URLSearchParams(window.location.search);
    const allowedParams = TAB_SPECIFIC_PARAMS['warehouseproduct'] || [];

    allowedParams.forEach(key => {
        if (currentUrlParams.has(key) && currentUrlParams.get(key)) {
            window.currentWarehouseFilters[key] = currentUrlParams.get(key);
        }
    });
    console.log("üöÄ initWarehouseTab: currentWarehouseFilters from URL (URL keys):", JSON.parse(JSON.stringify(window.currentWarehouseFilters)));

    updateWarehouseFilterControlsUI(); // Must use window.currentWarehouseFilters with URL keys
    bindWarehouseFiltersButtons();    // Must ensure this calls updateWarehouseTabFilters with URL keys
    bindWarehouseSearchInput();     // Must ensure this calls updateWarehouseTabFilters with URL keys
    initSelectAll(); initCreatePoButton(); initHealthyLevel();
    saveTabFiltersToSession('warehouseproduct', window.currentWarehouseFilters); // Save the state derived from URL
}

// ======= WAREHOUSE tab =======INIT
window.currentWarehouseFilters = {}; // Used by warehouse product tab

function bindWarehouseFiltersButtons() {
  const applyButtonHighlight = (key, value) => {
    // Ensure querySelectorAll is scoped correctly if filter buttons appear in multiple tabs
    // For warehouse tab, it might be within a specific container like '#warehouse-filters-panel'
    const filterButtonContainer = document.querySelector('#tab-content'); // Or a more specific parent
    if (!filterButtonContainer) return;

    filterButtonContainer.querySelectorAll(`.btn[data-filter="${key}"]`).forEach(btn => {
      const btnValue = btn.dataset.value;
      if (btnValue === value) {
        btn.classList.add("btn-neutral", "text-white");
        btn.classList.remove("btn-outline");
      } else {
        btn.classList.remove("btn-neutral", "text-white");
        btn.classList.add("btn-outline");
      }
    });
  };

  // Scope this to the warehouse tab's filter buttons to avoid affecting other tabs
  const warehouseTabContent = document.querySelector('#tab-content'); // Or a more specific container for warehouse filters
  if (!warehouseTabContent) return;

  warehouseTabContent.querySelectorAll('.btn[data-filter="warehouse"], .btn[data-filter="supplier"]').forEach(btn => {
    // Check if this button is indeed part of the warehouse product filters
    // This check might be more robust if you have a dedicated wrapper div for these filters.
    // For example, if your warehouse filters are inside <div id="warehouse-specific-filters">
    // then: if (!btn.closest('#warehouse-specific-filters')) return;

    // Prevent double binding if this function could be called multiple times on static content
    if (btn.dataset.warehouseFilterBound === 'true') return;

    btn.addEventListener('click', () => {
      const key = btn.dataset.filter; // This will be 'warehouse' or 'supplier'
      const value = btn.dataset.value;

      // REMOVE: const updateKey = key + "Id";
      // USE 'key' directly as it matches TAB_SPECIFIC_PARAMS and desired URL keys
      updateWarehouseTabFilters({ [key]: value }); // e.g., { warehouse: '1' } or { supplier: '2' }

      applyButtonHighlight(key, value); // Visually update the button
    });
    btn.dataset.warehouseFilterBound = 'true';
  });
}

function bindWarehouseSearchInput() {
  const input = document.querySelector('#warehouse-search-form input[name="q"]');
  if (!input) return;

  input.addEventListener("input", debounce(() => {
    const query = input.value.trim();
    updateWarehouseTabFilters({ q: input.value.trim() });
  }, 300));
}

function resetWarehouseProductFilters() {
    console.log("üîÑ Resetting Warehouse Product Filters (v5)");
    window.currentWarehouseFilters = {}; // Clear internal JS state (uses URL keys)
    clearTabFiltersFromSession('warehouseproduct');
    updateWarehouseFilterControlsUI(); // Visually reset controls based on empty state
    refreshWarehouseProductList(); // Will use empty currentWarehouseFilters
}

function initSelectAll() {
  const selectAll = document.getElementById("select-all");
  if (!selectAll) return;

  selectAll.addEventListener("change", function () {
    document.querySelectorAll(".select-item").forEach(cb => cb.checked = this.checked);
  });
}

function initCreatePoButton() {
  const createPoBtn = document.getElementById("create-po-btn");
  const confirmBtn = document.getElementById("confirm-create-po");

  if (createPoBtn) {
    createPoBtn.addEventListener("click", function () {
      const selectedIds = Array.from(document.querySelectorAll('.select-item:checked')).map(cb => cb.value);
      if (selectedIds.length === 0) {
        alert('Please select at least one product to create PO.');
        return;
      }
      openCreatePoModal(selectedIds);
    });
  }

  if (confirmBtn) {
    confirmBtn.addEventListener("click", confirmCreatePo);
  }
}

function initHealthyLevel() {
  const healthyLevel = document.getElementById("healthy-level");
  if (!healthyLevel) return;

  healthyLevel.addEventListener("change", refreshGapInfo);
  healthyLevel.dispatchEvent(new Event("change")); // ÂàùÂßãÂåñËß¶Âèë
}

function refreshGapInfo() {
  const healthyMultiplier = parseFloat(document.getElementById('healthy-level')?.value || 1.5);

  document.querySelectorAll('.qty-progress').forEach(progress => {
    const quantity = parseFloat(progress.dataset.quantity);
    const threshold = parseFloat(progress.dataset.threshold);
    const healthyThreshold = threshold * healthyMultiplier;

    progress.max = healthyThreshold.toFixed(2);
    progress.value = quantity;

    const flexDiv = progress.closest('.flex');
    const qtyText = flexDiv?.querySelector('.qty-text');
    if (qtyText) {
      qtyText.innerHTML = `${quantity} / ${healthyThreshold.toFixed(0)}`;
    }
  });

  document.querySelectorAll('.gap-info').forEach(cell => {
    const quantity = parseFloat(cell.dataset.quantity);
    const threshold = parseFloat(cell.dataset.threshold);
    const healthyThreshold = threshold * healthyMultiplier;
    const gap = Math.max(0, healthyThreshold - quantity);

    let colorClass = "";
    if (gap <= 5) {
      colorClass = "border-green-500";
    } else {
      colorClass = "border-red-500";
    }

    cell.innerHTML = `
    <div class="bg-transparent border ${colorClass} px-2 py-1 rounded text-sm font-semibold">
      ${gap.toFixed(0)}
    </div>
  `;
  });
}


// ======= WAREHOUSE tab =======UTILS
function updateWarehouseTabFilters(newFilterStateChanges) { // e.g., { supplier: '1' } or { warehouse: '2'}
    console.log("‚öôÔ∏è updateWarehouseTabFilters received changes (expected URL keys):", newFilterStateChanges);

    // Directly merge into window.currentWarehouseFilters, assuming keys are already URL-compatible
    window.currentWarehouseFilters = { ...window.currentWarehouseFilters, ...newFilterStateChanges };

    for (const key in window.currentWarehouseFilters) { // Clean up empty/null values
        if (!window.currentWarehouseFilters[key]) { // Handles "", null, undefined
            delete window.currentWarehouseFilters[key];
        }
    }

    // Reset to page 1 on any filter change (except if the change was to the page itself)
    const changedKeys = Object.keys(newFilterStateChanges);
    if ((TAB_SPECIFIC_PARAMS['warehouseproduct'] || []).includes('page') &&
        changedKeys.some(k => k !== 'page')) {
        window.currentWarehouseFilters.page = '1';
    } else if (!window.currentWarehouseFilters.page && (TAB_SPECIFIC_PARAMS['warehouseproduct'] || []).includes('page')) {
         // If page was removed and other filters exist, set to 1. If no other filters, page can remain absent.
        if (Object.keys(window.currentWarehouseFilters).some(k=>k !== 'page' && window.currentWarehouseFilters[k])) {
             window.currentWarehouseFilters.page = '1';
        } else {
            delete window.currentWarehouseFilters.page; // Explicitly remove if it became undefined/null
        }
    }

    console.log("‚öôÔ∏è currentWarehouseFilters after update (URL keys):", JSON.parse(JSON.stringify(window.currentWarehouseFilters)));
    refreshWarehouseProductList();
}

function refreshWarehouseProductList() {
    console.log("üîÅ Refreshing Warehouse Products with JS state (URL keys):", JSON.parse(JSON.stringify(window.currentWarehouseFilters || {})));
    const paramsForFetchAndHistory = new URLSearchParams();
    const allowedParams = TAB_SPECIFIC_PARAMS['warehouseproduct'] || [];

    // Build paramsForFetchAndHistory from window.currentWarehouseFilters (which now has URL keys)
    for (const key in window.currentWarehouseFilters) {
        if (allowedParams.includes(key) && window.currentWarehouseFilters[key]) {
            paramsForFetchAndHistory.set(key, window.currentWarehouseFilters[key]);
        }
    }

    // If page is not in currentWarehouseFilters (e.g. after filter change without explicit page set)
    // and it's an allowed param, and other filters are active, default to page 1 for fetch.
    if (allowedParams.includes('page') && !paramsForFetchAndHistory.has('page') &&
        Object.keys(window.currentWarehouseFilters).some(k => k !== 'page' && window.currentWarehouseFilters[k])) {
        // paramsForFetchAndHistory.set('page', '1'); // Only add if other filters are present
    }

    const queryStringForFetch = paramsForFetchAndHistory.toString();
    const paramsForHistoryWithTab = new URLSearchParams(paramsForFetchAndHistory);
    paramsForHistoryWithTab.set('tab', 'warehouseproduct');
    const newUrlForHistory = `?${paramsForHistoryWithTab.toString()}`;

    history.pushState(null, '', newUrlForHistory);
    // Pass the object with URL keys to saveTabFiltersToSession
    saveTabFiltersToSession('warehouseproduct', Object.fromEntries(paramsForFetchAndHistory.entries()));

    fetch(`/warehouse/search/?${queryStringForFetch}`, { headers: { "X-Requested-With": "XMLHttpRequest" } })
        .then(res => res.text())
        .then(html => {
            const container = document.getElementById("search-results");
            if (container) container.innerHTML = html;
            requestAnimationFrame(refreshGapInfo);
            console.log("‚úÖ Warehouse List refreshed. URL updated. Session saved.");
            updateWarehouseFilterControlsUI();
        })
        .catch(err => console.error("üî¥ Failed to refresh warehouse products:", err));
}

function updateWarehouseFilterControlsUI() {
    const activeFilters = window.currentWarehouseFilters || {};
    const whTabContent = document.querySelector('#tab-content');
    if (!whTabContent) {
        console.warn("updateWarehouseFilterControlsUI: #tab-content not found, cannot update UI.");
        return;
    }

    ["warehouse", "supplier"].forEach(filterKey => { // URL keys
        const activeValue = activeFilters[filterKey] || "";
        whTabContent.querySelectorAll(`.btn[data-filter="${filterKey}"]`).forEach(btn => {
            if (btn.dataset.value === activeValue) {
                btn.classList.add("btn-neutral", "text-white"); btn.classList.remove("btn-outline");
            } else {
                btn.classList.remove("btn-neutral", "text-white"); btn.classList.add("btn-outline");
            }
        });
    });
    const searchInput = whTabContent.querySelector('#warehouse-search-form input[name="q"]');
    if (searchInput) searchInput.value = activeFilters.q || "";
    console.log("üé® Warehouse Filter controls UI updated based on JS state (URL keys).");
}
// ======= WAREHOUSE tab =======MODAL
function openDetails(pk) {
  fetch(`/warehouse/warehouseproduct/${pk}/details/`, {
    headers: {
      'X-Requested-With': 'XMLHttpRequest'
    }
  })
  .then(response => response.json())
  .then(data => {
    if (data.error) {
      alert("Failed to load details");
      return;
    }

    document.getElementById("modal-product-name").textContent = data.product;
    document.getElementById("modal-warehouse-name").textContent = data.warehouse;
    document.getElementById("modal-batch-number").textContent = data.batch_number;
    document.getElementById("modal-expiry-date").textContent = data.expiry_date;
    document.getElementById("modal-quantity").textContent = data.quantity;
    document.getElementById("modal-threshold").textContent = data.threshold;

    document.getElementById("details-modal").checked = true;  // ÊâìÂºÄ Modal
  })
  .catch(error => {
    console.error("Error loading details:", error);
    alert("Error loading details");
  });
}

function openCreatePoModal(selectedIds) {
  const multiplier = parseFloat(document.getElementById("healthy-level")?.value || 1.5);

  fetch("{% url 'warehouse:prepare_po_from_selection' %}", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": '{{ csrf_token }}',
    },
    body: JSON.stringify({
      selected_items: selectedIds,
      healthy_multiplier: multiplier,
    })
  })
  .then(response => response.json())
  .then(data => {
    if (!data.success) {
      alert("Failed to prepare PO data");
      return;
    }

    fillCreatePoModal(data.data); // ‚ú® Ê∏≤Êüìmodal
    document.getElementById("create-po-modal").checked = true;
  })
  .catch(error => {
    console.error("Error preparing PO:", error);
  });
}

function fillCreatePoModal(poData) {
  const container = document.getElementById('create-po-modal-content');
  container.innerHTML = "";  // Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ

  poData.forEach(po => {
    const supplierDiv = document.createElement('div');
    supplierDiv.classList.add('space-y-2', 'border', 'border-gray-200', 'rounded', 'p-4', 'mb-4');

    const supplierTitle = document.createElement('h4');
    supplierTitle.classList.add('text-lg', 'font-semibold', 'text-gray-700');
    supplierTitle.textContent = `Supplier: ${po.supplier_name}`;
    supplierDiv.appendChild(supplierTitle);

    po.products.forEach(product => {
      const row = document.createElement('div');
      row.classList.add('flex', 'items-center', 'space-x-4', 'bg-gray-50', 'p-2', 'rounded');

      row.innerHTML = `
        <div class="w-1/3 truncate">${product.product_name} @ ${product.warehouse_name}</div>
        <div class="w-1/3 text-sm text-gray-500">Gap: ${product.gap}</div>
        <div class="w-1/3 flex gap-2 items-center">
          <input type="number" min="1" value="${product.gap}"
                 class="input input-sm input-bordered w-full quantity-input"
                 data-warehouse-product-id="${product.warehouse_product_id}"
                 data-supplier-id="${po.supplier_id}">
          <button type="button" class="btn btn-xs btn-error remove-row" title="Remove">‚úï</button>
        </div>
      `;

      supplierDiv.appendChild(row);
    });

    container.appendChild(supplierDiv);
  });

  // ‚úÖ Âä†ËΩΩÂÆåÂêéÁªôÊâÄÊúâ "Remove" ÊåâÈíÆÁªëÂÆö‰∫ã‰ª∂
  document.querySelectorAll('.remove-row').forEach(button => {
    button.addEventListener('click', function () {
      this.closest('.flex').remove();
    });
  });
}

function confirmCreatePo() {
  const inputs = document.querySelectorAll('.quantity-input');
  const payload = {};

  inputs.forEach(input => {
    const supplierId = input.dataset.supplierId;
    const wpId = input.dataset.warehouseProductId;
    const quantity = parseInt(input.value, 10);

    if (!payload[supplierId]) {
      payload[supplierId] = [];
    }

    payload[supplierId].push({
      warehouse_product_id: wpId,
      quantity: quantity,
    });
  });

  // ‚úÖ ÊòæÁ§∫Âä†ËΩΩ spinnerÔºàÂèØÈÄâÂä†ÊåâÈíÆ disableÔºâ
  const confirmBtn = document.getElementById('confirm-create-po');
  if (confirmBtn) {
    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<span class="loading loading-spinner"></span> Creating...';
  }

  fetch("{% url 'warehouse:confirm_create_po' %}", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-CSRFToken": '{{ csrf_token }}',
    },
    body: JSON.stringify({ orders: payload })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      console.log("confirm_create_po response:", data);
      Swal.fire({
        icon: 'success',
        title: 'PO Created!',
        toast: true,
        position: 'top-end',
        timer: 1500,
        showConfirmButton: false
      });

      // ‚úÖ Ê®°ÊãüÁÇπÂáª PurchaseOrders tabÔºåËá™Âä®ÂàáÊç¢ + È´ò‰∫Æ + ÂõûÂà∞È°∂ÈÉ®
      setTimeout(() => {
        const purchaseOrderTab = document.querySelector('.tabs a[href="?tab=purchaseorders"]');
        if (purchaseOrderTab) {
          purchaseOrderTab.click();

          // ‚úÖ Wait for the tab content to load before scrolling
          const tabContentObserver = new MutationObserver((mutations) => {
            const poCard = document.getElementById(`po-card-${data.latest_po_id}`);
            if (poCard) {
              poCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
              tabContentObserver.disconnect(); // Stop observing
            } else {
              console.warn(`PO Card with ID 'po-card-${data.latest_po_id}' still not found after tab load.`);
            }
          });

          const tabContent = document.getElementById('tab-content');
          if (tabContent) {
            tabContentObserver.observe(tabContent, { childList: true, subtree: true });
          }

        }
      }, 300);

    } else {
      Swal.fire({
        icon: 'error',
        title: 'Creation Failed',
        text: data.error || 'Something went wrong.',
      });
    }
  })
  .catch(error => {
    console.error("Error confirming PO:", error);
    Swal.fire({
      icon: 'error',
      title: 'Network Error',
      text: 'Please try again later.',
    });
  })
  .finally(() => {
    if (confirmBtn) {
      confirmBtn.disabled = false;
      confirmBtn.innerHTML = 'Confirm Create';
    }
  });
}





// =========================== PurchaseOrders Tab Initializer
function initPurchaseOrderTab() {
    const container = document.querySelector('#tab-content');
    if (!container) {
        console.warn("initPurchaseOrderTab: #tab-content container not found.");
        return;
    }
    console.log("üöÄ Initializing PurchaseOrder Tab JS (vJS-Standardized)");

    // Load initial filters from URL or session
    pendingPOFilters = {}; // Reset or implement your existing loading logic
    const currentUrlParams = new URLSearchParams(window.location.search);
    const allowedParams = TAB_SPECIFIC_PARAMS['purchaseorders'] || [];

    allowedParams.forEach(key => {
        if (currentUrlParams.has(key) && currentUrlParams.get(key)) {
            pendingPOFilters[key] = currentUrlParams.get(key);
        }
    });

    // If coming to the tab with no specific filters from URL/session,
    // ensure 'page' is not unnecessarily set, or set to '1' if a default list should load.
    if (Object.keys(pendingPOFilters).length === 0 && (TAB_SPECIFIC_PARAMS['purchaseorders'] || []).includes('page')) {
        // If you always want page 1 to load by default even with no filters:
        // pendingPOFilters.page = '1';
        // Or, if no filters means no 'page' parameter:
        delete pendingPOFilters.page;
    }

    console.log("üöÄ initPurchaseOrderTab: Initial pendingPOFilters determined:", JSON.parse(JSON.stringify(pendingPOFilters)));

    // Bind the main filter panel controls (search, status dropdowns etc.)
    // These listeners are on static elements or use delegation.
    updatePOFilterControlsUI(); // Visually set filter controls based on pendingPOFilters
    bindPOFilterControls(container); // Attaches listeners to filter controls

    // Directly call refreshPOList to fetch data using the current pendingPOFilters.
    // This ensures that the list is populated from the AJAX endpoint which includes status_dates.
    refreshPOList();

    // saveTabFiltersToSession is called within refreshPOList after data is fetched
    // and pagination state (like current page) is confirmed.
}




// ======= PURCHASEORDER Tab =======INIT
// --- New variables for Purchase Order filter debouncing ---
const PO_FILTER_DEBOUNCE_DELAY = 400; // milliseconds

function refreshPOList() {
    console.log("üöÄ refreshPOList with pendingPOFilters (URL keys):", JSON.parse(JSON.stringify(pendingPOFilters)));
    const paramsForFetchAndHistory = new URLSearchParams();
    const allowedParams = TAB_SPECIFIC_PARAMS['purchaseorders'] || [];

    for (const key in pendingPOFilters) {
        if (allowedParams.includes(key) && pendingPOFilters[key]) {
            paramsForFetchAndHistory.set(key, pendingPOFilters[key]);
        }
    }

    // Default to page 1 if page is an allowed param, not present, and other filters exist
    if (allowedParams.includes('page') && !paramsForFetchAndHistory.has('page') &&
        Array.from(paramsForFetchAndHistory.keys()).some(k => k !== 'page')) {
        paramsForFetchAndHistory.set('page', '1');
    }

    const queryStringForFetch = paramsForFetchAndHistory.toString();
    const paramsForHistoryWithTab = new URLSearchParams(paramsForFetchAndHistory);
    paramsForHistoryWithTab.set('tab', 'purchaseorders');
    const newUrlForHistory = `?${paramsForHistoryWithTab.toString()}`;

    history.pushState({ path: newUrlForHistory, tab: 'purchaseorders' }, '', newUrlForHistory);
    // Save the actual parameters used for the fetch (including defaulted page 1)
    saveTabFiltersToSession('purchaseorders', Object.fromEntries(paramsForFetchAndHistory.entries()));

    const poListContainer = document.getElementById("purchase-orders-list");

    fetch(`/warehouse/purchaseorders/filter-data/?${queryStringForFetch}`, {
        headers: { "X-Requested-With": "XMLHttpRequest" }
    })
    .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
    })
    .then(data => {
        console.log("[refreshPOList] Received JSON data from fetch. Type:", typeof data); // Value logged below
        // console.log("[refreshPOList] Full JSON data from fetch:", JSON.stringify(data, null, 2)); // Keep for debugging

        if (!data || typeof data.current_user_is_superuser === 'undefined') {
            console.error("[refreshPOList] CRITICAL: 'data' from fetch is invalid or missing current_user_is_superuser!", data);
            if (poListContainer) {
                const itemListContainerError = poListContainer.querySelector('#item-list-container');
                if (itemListContainerError) itemListContainerError.innerHTML = '<p class="text-red-500 text-center">Error: Failed to fetch data (#E01).</p>';
                else poListContainer.innerHTML = '<p class="text-red-500 text-center">Error: UI container missing (#E02).</p>';
            }
            return;
        }

        if (poListContainer) {
            updatePOListUI(poListContainer, data.purchase_orders, data); // This renders cards and modals
            updatePaginationStates(data); // Updates pendingPOFilters.page and saves to session

            // ---- START: Make the list visible after JS rendering ----
          const itemListContainer = poListContainer.querySelector('#item-list-container');
          if (itemListContainer) {
            itemListContainer.classList.remove('initially-hidden');
          }
          // ---- END: Make the list visible ----

            // Re-initialize or set up UI components for the newly rendered content
            initializePOModalStatusButtons(poListContainer); // Sets visual state for status buttons in new modals
            initLoadMorePOs(); // Sets up "Load More" button if present

            // These setup delegated listeners on a persistent parent.
            // They typically only need to be called once if the parent (#purchase-orders-list) is persistent.
            // If #purchase-orders-list itself is replaced, they would need to be recalled.
            // Assuming #purchase-orders-list is the persistent container for POs:
            setupPOModalDelegatedInteractivity('#purchase-orders-list');
            setupStatusButtonDelegation('#purchase-orders-list');
            initReceiveItemsModal(); // Sets up delegated listener for "Receive Items"

            console.log("‚úÖ PO List refreshed via AJAX. UI updated and all dependent components initialized.");
        } else {
            console.error("[refreshPOList] poListContainer not found for applying updates!");
        }
    })
    .catch(error => {
        console.error("‚ùå Failed to refresh PO list (FETCH CATCH BLOCK):", error);
        if (poListContainer) {
            const itemListContainerError = poListContainer.querySelector('#item-list-container');
            if (itemListContainerError) itemListContainerError.innerHTML = `<p class="text-red-500 text-center">Error: ${error.message}.</p>`;
            else poListContainer.innerHTML = `<p class="text-red-500 text-center">Error: ${error.message}. UI container missing. (#E03)</p>`;
        }
      });
}

const debouncedRefreshPOList = debounce(refreshPOList, PO_FILTER_DEBOUNCE_DELAY);

function updatePOFilterControlsUI() {
  const container = document.querySelector('#tab-content'); // Or a more specific filter panel container
  if (!container) return;

  // Update filter buttons (status, supplier)
  ["status", "supplier"].forEach(filterKey => {
    const activeValue = pendingPOFilters[filterKey] || "";
    container.querySelectorAll(`.btn[data-filter="${filterKey}"]`).forEach(btn => {
      if (btn.dataset.value === activeValue) {
        btn.classList.add("btn-neutral", "text-white");
        btn.classList.remove("btn-outline");
      } else {
        btn.classList.remove("btn-neutral", "text-white");
        btn.classList.add("btn-outline");
      }
    });
  });

  // Update search input
  const searchInput = container.querySelector('#po-search-form input[name="q"]');
  if (searchInput) {
    searchInput.value = pendingPOFilters.q || "";
  }
  console.log("üé® PO Filter controls UI updated.");
}

function bindPOFilterControls(container) {
  // Event listener for filter buttons (status, supplier)
  container.addEventListener("click", (e) => {
    const btn = e.target.closest(".btn[data-filter]");
    if (!btn || (btn.dataset.filter !== "status" && btn.dataset.filter !== "supplier")) return;

    const key = btn.dataset.filter;
    const value = btn.dataset.value;

    if (value === "") {
      delete pendingPOFilters[key]; // Or pendingPOFilters[key] = "";
    } else {
      pendingPOFilters[key] = value;
    }
    pendingPOFilters.page = '1'; // Reset to page 1 on filter change

    updatePOFilterControlsUI(); // Immediate visual feedback
    debouncedRefreshPOList();
    console.log(`üëâ PO Filter button clicked: ${key}=${value}. Pending:`, JSON.parse(JSON.stringify(pendingPOFilters)));
  });

  // Event listener for search input
  const searchInput = container.querySelector('#po-search-form input[name="q"]');
  if (searchInput) {
    searchInput.addEventListener("input", debounce(() => {
      const query = searchInput.value.trim();
      if (query === "") {
        delete pendingPOFilters.q;
      } else {
        pendingPOFilters.q = query;
      }
      pendingPOFilters.page = '1'; // Reset to page 1 on search change
      // updatePOFilterControlsUI(); // Search input updates itself visually
      debouncedRefreshPOList();
      console.log(`üîç PO Search input changed: q=${query}. Pending:`, JSON.parse(JSON.stringify(pendingPOFilters)));
    }, PO_FILTER_DEBOUNCE_DELAY + 100)); // Slightly longer debounce for typing
  }
}

function bindPOListPagination(poListContainer) {
  poListContainer.querySelectorAll(".pagination-link").forEach(link => {
    link.addEventListener("click", function(e) {
      e.preventDefault();
      const url = new URL(this.href);
      const page = url.searchParams.get("page");
      if (page) {
        pendingPOFilters.page = page;
        // updatePOFilterControlsUI(); // No direct filter controls change, but URL will
        refreshPOList(); // Refresh immediately, no debounce for pagination
        console.log(`üìÑ PO Pagination link clicked: page=${page}`);
      }
    });
  });
}

function resetPurchaseOrderFilters() {
    console.log("üîÑ Resetting Purchase Order Filters (v4)");
    pendingPOFilters = {}; // Clear internal JS state
    if ((TAB_SPECIFIC_PARAMS['purchaseorders'] || []).includes('page')) {
        // pendingPOFilters.page = '1'; // Don't force page=1 for a truly empty state
    }
    clearTabFiltersFromSession('purchaseorders');
    debouncedRefreshPOList.cancel();
    updatePOFilterControlsUI();
    refreshPOList(); // Will use empty pendingPOFilters, URL becomes ?tab=purchaseorders, session saves ""
}

function initializePOModalStatusButtons(container) {
    if (!container) return;
    console.log("üé® Initializing PO Modal Status Button visuals within:", container.id || container.tagName);

    container.querySelectorAll('.modal-box[data-po-id]').forEach(modalBox => {
        const poId = modalBox.dataset.poId;
        const hiddenStatusInput = modalBox.querySelector(`input[type="hidden"][name="selected_status"][id="selected-status-${poId}"]`);
        if (!hiddenStatusInput) return; // Skip if not an update PO modal

        const currentPoStatus = hiddenStatusInput.value;
        const statusButtons = modalBox.querySelectorAll(`.status-select-btn[data-po-id="${poId}"]:not([disabled])`);

        if (statusButtons.length === 0) {
            console.warn(`PO #${poId}: No ENABLED status-select-btn found during visual init.`);
        }

        statusButtons.forEach(button => {
            const buttonStatusValue = button.dataset.status;
            if (buttonStatusValue === currentPoStatus) {
                button.classList.add('btn-neutral', 'text-white'); button.classList.remove('btn-outline');
            } else {
                button.classList.remove('btn-neutral', 'text-white'); button.classList.add('btn-outline');
            }
        });
    });
     console.log("üëç PO Modal Status Button visuals initialization complete.");
}


/**
 * Sets up event delegation for status button clicks within a persistent parent container.
 * This only needs to be called ONCE when the main tab structure is set up or the PO tab is first loaded.
 * @param {string} parentSelector - The selector for the persistent parent element (e.g., '#purchase-orders-list' or '#tab-content').
 */
function setupStatusButtonDelegation(parentSelector) {
    const parentElement = document.querySelector(parentSelector);
    if (!parentElement) {
        console.error(`setupStatusButtonDelegation: Parent element "${parentSelector}" not found.`);
        return;
    }

    if (parentElement.dataset.statusDelegationBound === 'true') {
        console.log(`Status button delegation already bound to ${parentSelector}.`);
        return;
    }

    console.log(`üöÄ Setting up DELEGATED click listener for status buttons on "${parentSelector}"`);
    parentElement.addEventListener('click', function(event) {
        console.log(`[DELEGATED] Click detected inside ${parentSelector}. Target:`, event.target);
        const statusButton = event.target.closest('.status-select-btn:not([disabled])');

        if (statusButton && statusButton.closest('.modal-box[data-po-id]')) {
            console.log("[DELEGATED] Click target IS an enabled status button inside a PO modal box.");
            event.preventDefault();
            try {
                const clickedPoId = statusButton.dataset.poId;
                const newStatus = statusButton.dataset.status;
                const parentModalBox = statusButton.closest('.modal-box');
                const specificHiddenInput = parentModalBox.querySelector(`input#selected-status-${clickedPoId}`);

                if (!specificHiddenInput) { console.error(`PO #${clickedPoId}: [DELEGATED] Critical - could not find hidden input on click!`); return; }

                console.log(`PO #${clickedPoId}: [DELEGATED] Status btn '${newStatus}' CLICKED. Old hidden: '${specificHiddenInput.value}', New: '${newStatus}'`);
                specificHiddenInput.value = newStatus;

                parentModalBox.querySelectorAll(`.status-select-btn[data-po-id="${clickedPoId}"]:not([disabled])`).forEach(btn => {
                    btn.classList.remove('btn-neutral', 'text-white'); btn.classList.add('btn-outline');
                });
                statusButton.classList.add('btn-neutral', 'text-white'); statusButton.classList.remove('btn-outline');
                console.log(`PO #${clickedPoId}: [DELEGATED] Button '${newStatus}' visually set active.`);
            } catch (error) {
                console.error("Error inside delegated status button click handler:", error);
            }
        } else {
             // console.log("[DELEGATED] Click target was not an enabled status button inside a PO modal box.");
        }
    });
    parentElement.dataset.statusDelegationBound = 'true';
}

function setupPOModalDelegatedInteractivity(parentSelector) {
    const parentElement = document.querySelector(parentSelector);
    if (!parentElement) {
        console.error(`setupPOModalDelegatedInteractivity: Parent element "${parentSelector}" not found.`);
        return;
    }

    if (parentElement.dataset.poModalDelegationBound === 'true') {
        console.log(`PO Modal Form/Delete delegation already bound to ${parentSelector}.`);
        return;
    }

    console.log(`üöÄ Setting up DELEGATED listeners for PO Modal Forms & Delete on "${parentSelector}"`);

    // Delegated listener for PO Update Form submissions
    parentElement.addEventListener('submit', function(event) {
    const updateForm = event.target.closest('form.po-update-form'); // Changed variable name for clarity
    if (updateForm) {
        event.preventDefault();
        const poId = updateForm.dataset.poId;
        console.log(`[DELEGATED SUBMIT] Caught submit for po-update-form. PO ID: ${poId}`);
        console.log(`[DELEGATED SUBMIT] Form action: ${updateForm.action}`);
        console.log(`[DELEGATED SUBMIT] Form element:`, updateForm);

        // Ensure saveForm is being called with the correct parameters
        saveForm(updateForm, poId, `modal-update-po-${poId}`, "PO Updated!");
      }
    });

    // Delegated listener for PO Edit Items Form submissions
    parentElement.addEventListener('submit', function(event) {
        const form = event.target.closest('form.po-edit-form');
        if (form) {
            event.preventDefault();
            const poId = form.dataset.poId;
            console.log(`[DELEGATED] Submitting PO Edit Items form for PO ID: ${poId}`);
            saveForm(form, poId, `modal-edit-items-${poId}`, "PO Items Saved!");
        }
    });

    // Delegated listener for Delete PO buttons
    parentElement.addEventListener('click', function(event) {
        const deleteButton = event.target.closest('button.delete-po-btn');
        if (deleteButton) {
            // No preventDefault needed unless it's a submit button itself
            const poId = deleteButton.dataset.poId;
            console.log(`[DELEGATED] Clicked Delete PO button for PO ID: ${poId}`);
            deletePo(poId);
        }
    });

    parentElement.dataset.poModalDelegationBound = 'true';

    // Note: The initialization of status button *visuals* (making the current status active)
    // still needs to happen after new modal content is loaded if it's not handled by CSS alone.
    // The CLICK handling for status buttons is already delegated by setupStatusButtonDelegation.
    // So, initializePOModalStatusButtons(container) might still be needed after AJAX updates
    // if you need to dynamically set which button looks "active" based on data.
}

function bindPOModalDirectInteractivity(container) {
    if (!container) { console.error("bindPOModalDirectInteractivity: Container not provided."); return; }
    console.log("üîß Binding PO Modal DIRECT Interactivity (Forms, Delete) & Init Visuals within:", container.id || container.tagName);

    // Bind form submissions (Update PO)
    container.querySelectorAll('form.po-update-form').forEach(form => {
        if (form.dataset.directUpdateFormBound === 'true') return;
        form.addEventListener('submit', function(e) { /* ... (saveForm logic) ... */ e.preventDefault(); const poId=this.dataset.poId; saveForm(this, poId, `modal-update-po-${poId}`, "PO Updated!"); });
        form.dataset.directUpdateFormBound = 'true';
    });

    // Bind form submissions (Edit Items)
    container.querySelectorAll('form.po-edit-form').forEach(form => {
        if (form.dataset.directEditFormBound === 'true') return;
        form.addEventListener('submit', function(e) { /* ... (saveForm logic) ... */ e.preventDefault(); const poId=this.dataset.poId; saveForm(this, poId, `modal-edit-items-${poId}`, "PO Items Saved!"); });
        form.dataset.directEditFormBound = 'true';
    });

    // Bind delete buttons
    container.querySelectorAll('button.delete-po-btn').forEach(button => {
        if (button.dataset.directDeleteBtnBound === 'true') return;
        button.addEventListener('click', function() { /* ... (deletePo logic) ... */ const poId=this.dataset.poId; deletePo(poId); });
        button.dataset.directDeleteBtnBound = 'true';
    });

    // Initialize Status Button Visuals
    initializePOModalStatusButtons(container);

    console.log("üëç PO Modal DIRECT Interactivity binding complete.");
}

function initReceiveItemsModal() {
  const poListContainer = document.getElementById("purchase-orders-list");
  if (!poListContainer) {
    console.warn("initReceiveItemsModal: #purchase-orders-list container not found.");
    return;
  }

  // Check if the listener is already bound to prevent multiple attachments
  if (poListContainer.dataset.receiveItemsDelegationBound === 'true') {
    // console.log("Receive Items delegation already bound to #purchase-orders-list.");
    return;
  }

  console.log("üõçÔ∏è Setting up DELEGATED listener for 'Receive Items' buttons on #purchase-orders-list.");
  poListContainer.addEventListener('click', (event) => {
    // Target only the specific "Receive" trigger label with a data-po-id
    const receiveTriggerButton = event.target.closest('label.receive-items-trigger[data-po-id]');

    if (receiveTriggerButton) {
      event.preventDefault(); // Good practice for labels acting as buttons
      const poId = receiveTriggerButton.dataset.poId;

      if (poId) {
        console.log('[DELEGATED] Click detected on receive items trigger for PO ID:', poId);
        openReceiveItemsModal(poId); // This should now be the only call path
      } else {
        console.warn("[DELEGATED] Receive items trigger clicked, but poId is missing from data-po-id attribute.", receiveTriggerButton);
      }
    }
  });

  poListContainer.dataset.receiveItemsDelegationBound = 'true';
}


function openReceiveItemsModal(poId) {
  console.log("openReceiveItemsModal called with PO ID:", poId); // Debug
  const modalContainer = document.getElementById('receive-items-modal-container');
  modalContainer.innerHTML = '<span class="loading loading-spinner"></span> Loading...'; // Show loading

  fetch(`/warehouse/po/${poId}/get-items-for-receiving/`, {
    headers: {
      'X-Requested-With': 'XMLHttpRequest'
    }
  })
  .then(response => response.json())
  .then(data => {
    if (!data.success) {
      modalContainer.innerHTML = `<p class="text-red-500">Error: ${data.message || 'Failed to load receipt data.'}</p>`;
      return;
    }

    const modalContent = `
      <input type="checkbox" id="modal-receive-items" class="modal-toggle" checked />
      <div class="modal" role="dialog">
        <div class="modal-box max-w-2xl">
          <h3 class="font-bold text-lg mb-4">Receive Items for PO #${data.po_id}</h3>
          <form id="receive-items-form-${data.po_id}" data-po-id="${data.po_id}">
            {% csrf_token %}
            <table class="table w-full">
              <thead>
                <tr>
                  <th>SKU</th>
                  <th>Product</th>
                  <th>Ordered</th>
                  <th>Received</th>
                  <th>Receive Now</th>
                </tr>
              </thead>
              <tbody>
                ${data.items.map(item => `
                  <tr>
                    <td>${item.sku}</td>
                    <td>${item.name}</td>
                    <td>${item.ordered_quantity}</td>
                    <td>${item.already_received_quantity}</td>
                    <td>
                      <input
                        type="number"
                        name="receive_qty_${item.po_item_id}"
                        value="${item.balance_quantity}"
                        min="0"
                        max="${item.balance_quantity}"
                        class="input input-sm input-bordered w-24 receive-qty-input"
                        data-po-item-id="${item.po_item_id}"
                      />
                    </td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
            <textarea name="receipt_notes" class="textarea textarea-bordered w-full mt-4" placeholder="Receipt Notes"></textarea>
            <div class="modal-action justify-between mt-4">
              <label for="modal-receive-items" class="btn btn-sm">Cancel</label>
              <button type="button" class="btn btn-sm btn-primary" onclick="submitReceiveItemsForm('${data.po_id}')">
                Process Receipt
              </button>
            </div>
          </form>
        </div>
      </div>
    `;
    modalContainer.innerHTML = modalContent;
  })
  .catch(error => {
    console.error("Error fetching receive items:", error);
    modalContainer.innerHTML = `<p class="text-red-500">Error: ${error.message || 'Failed to load receipt data.'}</p>`;
  });
}

function submitReceiveItemsForm(poId) {
  const form = document.getElementById(`receive-items-form-${poId}`);
  if (!form) {
    console.error(`Form with ID 'receive-items-form-${poId}' not found.`);
    return;
  }

  const formData = new FormData(form);
  const items = [];
  form.querySelectorAll('.receive-qty-input').forEach(input => {
    const poItemId = input.dataset.poItemId;
    const quantityReceivedNow = parseInt(input.value, 10);
    if (quantityReceivedNow > 0) {
      items.push({ po_item_id: parseInt(poItemId), quantity_received_now: quantityReceivedNow });
    }
  });

  const payload = {
    items: items,
    notes: formData.get('receipt_notes')
  };

  fetch(`/warehouse/po/${poId}/process-receipt/`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
      'X-CSRFToken': getCsrfToken()
    },
    body: JSON.stringify(payload)
  })
  .then(response => response.json())
  .then(data => {
    if (data.success) {
      Swal.fire({
        toast: true,
        icon: 'success',
        title: 'Receipt Processed!',
        position: 'top-end',
        timer: 1500,
        showConfirmButton: false
      });

      // Close the modal and refresh the PO list
      closeModal('modal-receive-items');
      refreshPOList(); // Or update the specific PO card
    } else {
      Swal.fire({
        icon: 'error',
        title: 'Receipt Failed',
        text: data.message || 'Error processing receipt.',
      });
    }
  })
  .catch(error => {
    console.error('Error processing receipt:', error);
    Swal.fire({
      icon: 'error',
      title: 'Network Error',
      text: 'Please try again later.',
    });
  });
}

/**
 * MODIFIED FUNCTION
 * Updates the PO list UI by clearing and re-populating it.
 * @param {HTMLElement} poListContainer - The main container for the PO list (e.g., #purchase-orders-list).
 * @param {Array} purchaseOrdersJsonArray - Array of PO data objects.
 * @param {object} fullJsonData - The full JSON response from the server, including pagination and context.
 */
 function updatePOListUI(poListContainer, purchaseOrdersJsonArray, fullJsonData) {
    console.log("--- updatePOListUI Function START (vJS-FullFrag) ---");
    console.log("[updatePOListUI] Arg1 (poListContainer ID):", poListContainer ? poListContainer.id : 'null');
    console.log("[updatePOListUI] Arg3 (fullJsonData type):", typeof fullJsonData);


    const itemListContainer = poListContainer.querySelector('#item-list-container');
    if (!itemListContainer) {
        console.error("[updatePOListUI] CRITICAL: #item-list-container not found within poListContainer.");
        if (poListContainer) poListContainer.innerHTML = '<p class="text-red-500 text-center p-4">Error: UI sub-container #item-list-container is missing.</p>';
        return;
    }

    // Clear previous PO cards from the item list
    itemListContainer.innerHTML = '';
    // Clear previous dynamically added modals from the main poListContainer
    // These modals are now identified by 'po-specific-modal-toggle' and 'po-specific-modal-container' classes
    poListContainer.querySelectorAll('.po-specific-modal-toggle, .po-specific-modal-container').forEach(el => el.remove());

    if (!fullJsonData || typeof fullJsonData.current_user_is_superuser === 'undefined') {
        console.error("[updatePOListUI] ERROR: fullJsonData is invalid or missing 'current_user_is_superuser'.");
        itemListContainer.innerHTML = '<p class="text-red-500 text-center p-4">Error: Critical display data missing from server response.</p>';
        return;
    }

    const isSuperuser = fullJsonData.current_user_is_superuser;
    const statusChoices = fullJsonData.status_choices || [];
    const statusDates = fullJsonData.status_dates || {};
    // const nextStatuses = fullJsonData.next_statuses || {}; // Not directly used in modal HTML generation here but good to have

    if (!Array.isArray(purchaseOrdersJsonArray) || purchaseOrdersJsonArray.length === 0) {
        const noResultsMessage = document.createElement('p');
        noResultsMessage.className = 'text-center py-4 text-gray-500';
        noResultsMessage.textContent = 'No purchase orders found matching your criteria.';
        itemListContainer.appendChild(noResultsMessage);
    } else {
        const allCardsFragment = document.createDocumentFragment();
        const allModalsFragment = document.createDocumentFragment();

        purchaseOrdersJsonArray.forEach(poData => {
            const { cardHTMLFragment, modalsHTMLFragment } = createPoCardAndModalHTMLFragments(poData, isSuperuser, statusChoices, statusDates);
            allCardsFragment.appendChild(cardHTMLFragment);
            allModalsFragment.appendChild(modalsHTMLFragment);
        });
        itemListContainer.appendChild(allCardsFragment); // Append all cards to their container
        poListContainer.appendChild(allModalsFragment); // Append all modals to the main list container (or document.body if preferred)
    }

    // Manage "Load More" button (your existing logic for this should be here)
    const existingLoadMoreContainer = poListContainer.querySelector('div.load-more-button-container');
    if (existingLoadMoreContainer) {
        existingLoadMoreContainer.remove();
    }
    if (fullJsonData && fullJsonData.has_next) {
        const loadMoreContainer = document.createElement('div');
        loadMoreContainer.className = 'text-center mt-4 load-more-button-container';
        const loadMoreButton = document.createElement('button');
        loadMoreButton.id = 'explore-more-pos-btn';
        loadMoreButton.className = 'btn btn-outline';
        loadMoreButton.textContent = 'Explore More';
        loadMoreContainer.appendChild(loadMoreButton);
        // Append directly to poListContainer, after itemListContainer
        if(itemListContainer.nextSibling) {
            poListContainer.insertBefore(loadMoreContainer, itemListContainer.nextSibling);
        } else {
            poListContainer.appendChild(loadMoreContainer);
        }
    }
    console.log("--- updatePOListUI Function END (vJS-FullFrag) ---");
}

function updatePoCard(card, po) {
    console.log("Updating PO Card:", card, "with data:", po);
    if (!po) {
        console.error("PO data is null or undefined, skipping update");
        return;
    }

    if (po.status) {
        const statusLabel = card.querySelector('#status-label-' + po.id);
        if (statusLabel) {
            statusLabel.textContent = po.status_display || '';
            statusLabel.className = 'badge badge-lg py-5 font-semibold ' + getStatusBadgeClasses(po.status);
            console.log("Updated status for PO:", po.id, "to:", po.status_display);
        } else {
            console.warn("Status label not found for PO:", po.id);
        }
    }

    if (po.eta !== undefined && po.eta !== null) {
        const etaElement = card.querySelector('p.text-sm.text-gray-500');
        if (etaElement) {
            etaElement.textContent = `ETA: ${po.eta}`;
            console.log("Updated ETA for PO:", po.id, "to:", po.eta);
        } else {
            console.warn("ETA element not found for PO:", po.id);
        }
    } else if (po.eta === null) {
        const etaElement = card.querySelector('p.text-sm.text-gray-500');
        if (etaElement) {
            etaElement.textContent = `ETA: N/A`;
            console.log("Updated ETA for PO:", po.id, "to: N/A");
        } else {
            console.warn("ETA element not found for PO:", po.id);
        }
    }

    // Update items table
    const itemsTableBody = card.querySelector('table.table tbody');
    if (itemsTableBody && po.items && Array.isArray(po.items)) {
        itemsTableBody.innerHTML = ''; // Clear existing rows
        if (po.items.length > 0) {
            po.items.forEach(item => {
                if (item) {
                    try {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${item.sku || ''}</td>
                            <td>${item.name || ''}</td>
                            <td>${item.quantity}</td>
                            <td>${item.price}</td>
                            <td>${item.total_price}</td>
                        `;
                        itemsTableBody.appendChild(row);
                    } catch (e) {
                        console.error("Error creating row for item:", item, e);
                    }
                } else {
                    console.warn("Invalid item data in PO:", po.id);
                }
            });
            console.log("Updated items table for PO:", po.id);
        } else {
            console.log("No items to update for PO:", po.id);
        }
    } else {
        console.warn("Items table or data invalid for PO:", po.id, po.items);
    }

    // Update total amount
    const totalAmountElement = card.querySelector('.text-right.font-bold');
    if (po && po.total_amount !== undefined && po.total_amount !== null) {
        totalAmountElement.textContent = `Total Amount: ${po.total_amount}`;
        console.log("Updated total amount for PO:", po.id, "to:", po.total_amount);
    } else {
        console.warn("Total amount element or data invalid for PO:", po.id, po.total_amount);
    }

    // Update the "Receive Items" button visibility
    const receiveItemsButton = card.querySelector('label[for="modal-receive-items"]');
    if (receiveItemsButton) {
        if (po.status === 'PARTIALLY_DELIVERED' || po.status === 'DELIVERED') {
            receiveItemsButton.style.display = ''; // Show
        } else {
            receiveItemsButton.style.display = 'none'; // Hide
        }
    }

    // Update the "Update" and "Edit" buttons (Crucially Important)
    const updateButton = card.querySelector('label[for^="modal-update-po-"]');
    if (updateButton) {
        updateButton.style.display = 'inline-block'; // Ensure it's visible
    } else {
        console.warn("Update button not found for PO:", po.id);
    }

    const editButton = card.querySelector('label[for^="modal-edit-items-"]');
    if (data.current_user_is_superuser) {
        editButton.style.display = 'inline-block'; // Ensure it's visible
    } else {
        console.warn("Edit button not found for PO:", po.id);
    }
}

function getPoStatusDate(poIdForDate, statusCode, allStatusDates) { // Added allStatusDates parameter
    const poIdStr = String(poIdForDate);
    if (allStatusDates && allStatusDates[poIdStr] && allStatusDates[poIdStr][statusCode]) {
        // Use the new formatCustomDateTime helper
        return formatCustomDateTime(allStatusDates[poIdStr][statusCode]);
    }
    // If the date isn't present in statusDates, it means it's an actionable button,
    // so we don't return 'N/A' for the text itself, but the calling logic handles it.
    // For the purpose of this function, if date is not found, return 'N/A' or an empty string
    // to signify no date text should be displayed. Let's use 'N/A' for clarity if a date was expected.
    // However, the `updateModalButtonsHTML` logic already handles this.
    // This function is purely for formatting an *existing* date string.
    return 'N/A'; // Should only be called if a date string exists.
}


// function createPoCard(po, isSuperuser) {
//     if (!po || typeof po.id === 'undefined') {
//         console.warn("[createPoCard] Invalid PO data received:", po);
//         return null;
//     }

//     console.log("[createPoCard] Creating card for PO ID:", po.id, "isSuperuser:", isSuperuser);
//     const card = document.createElement('div');
//     card.id = `po-card-${po.id}`;
//     card.className = 'bg-base-100 shadow rounded-xl p-4 relative mb-6 po-card';

//     // Safely determine supplier name. Adjust if your JSON 'po.supplier' is always a string.
//     const supplierName = (po.supplier && typeof po.supplier === 'object' && po.supplier.name) ? po.supplier.name : (po.supplier || 'N/A');

//     let itemsHtml = '';
//     if (po.items && Array.isArray(po.items)) {
//         itemsHtml = po.items.map(item => {
//             return item ? `
//                 <tr>
//                     <td>${item.sku || 'N/A'}</td>
//                     <td>${item.name || 'N/A'}</td>
//                     <td>${item.quantity || 0}</td>
//                     <td>${item.price || '0.00'}</td>
//                     <td>${item.total_price || '0.00'}</td>
//                 </tr>
//             ` : '';
//         }).join('');
//         if (!itemsHtml.trim()) { // If all items were null or produced empty strings
//              itemsHtml = '<tr><td colspan="5" class="text-center">Item data seems incomplete.</td></tr>';
//         }
//     } else {
//         itemsHtml = '<tr><td colspan="5" class="text-center">No items found for this PO.</td></tr>';
//     }

//     let etaDateFormatted = 'N/A';
//     if (po.eta) {
//         try {
//             const dateObj = new Date(po.eta + 'T00:00:00'); // Ensure parsing as local date, not UTC
//             if (!isNaN(dateObj)) {
//                  etaDateFormatted = dateObj.toLocaleDateString(undefined, { day: '2-digit', month: '2-digit', year: 'numeric', weekday: 'long' });
//             } else {
//                 etaDateFormatted = po.eta; // Fallback if date is invalid
//             }
//         } catch (e) {
//             console.warn(`[createPoCard] Could not parse ETA date for PO ${po.id}:`, po.eta, e);
//             etaDateFormatted = po.eta;
//         }
//     }

//     let lastUpdatedFormatted = 'N/A';
//     if (po.last_updated_date) {
//          try {
//             const dateObj = new Date(po.last_updated_date);
//              if (!isNaN(dateObj)) {
//                 lastUpdatedFormatted = dateObj.toLocaleString(undefined, { day: '2-digit', month: '2-digit', year: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit' });
//             } else {
//                 lastUpdatedFormatted = po.last_updated_date; // Fallback
//             }
//         } catch (e) {
//             console.warn(`[createPoCard] Could not parse last_updated_date for PO ${po.id}:`, po.last_updated_date, e);
//             lastUpdatedFormatted = po.last_updated_date;
//         }
//     }
//     console.log(`[createPoCard] For PO ID: ${po.id}, isSuperuser value: ${isSuperuser}`); // <-- ADD THIS LOG

//     card.innerHTML = `
//         <div class="absolute top-0 left-0 h-2 w-full rounded-t-xl ${getStatusStripeClasses(po.status || 'UNKNOWN')}"></div>
//         <div class="flex justify-between items-start mt-4">
//             <div>
//                 <h3 class="text-lg font-semibold">PO #${po.id} - ${supplierName}</h3>
//                 <p class="text-sm text-gray-500">ETA: ${etaDateFormatted}</p>
//             </div>
//             <div class="flex items-center gap-x-4">
//                 <span id="status-label-${po.id}" class="badge badge-lg py-5 font-semibold ${getStatusBadgeClasses(po.status || 'UNKNOWN')}">
//                     ${po.status_display || po.status || 'Unknown Status'}
//                 </span>
//                 <label for="modal-update-po-${po.id}" class="btn btn-sm btn-outline">Update</label>
//                 ${(po.status === 'PARTIALLY_DELIVERED' || po.status === 'DELIVERED') ?
//                 `<label for="modal-receive-items" class="btn btn-sm btn-outline receive-items-trigger"
//                   data-po-id="${po.id}"> Receive</label>`
//         : ''
//                 }
//             </div>
//         </div>
//         <div class="mt-4">
//             <table class="table w-full table-sm">
//                 <thead>
//                     <tr>
//                         <th>SKU</th>
//                         <th>Item</th>
//                         <th>Qty</th>
//                         <th>Unit Price</th>
//                         <th>Total</th>
//                     </tr>
//                 </thead>
//                 <tbody>
//                     ${itemsHtml}
//                 </tbody>
//             </table>
//             <div class="flex justify-between items-center mt-4">
//                 <p class="text-sm text-gray-500">
//                     Last updated: ${lastUpdatedFormatted}
//                 </p>
//                 <div class="text-right font-bold">
//                     Total Amount: ${po.total_amount || '0.00'}
//                     ${isSuperuser ? `<label for="modal-edit-items-${po.id}" class="btn btn-sm btn-outline edit-po-action">Edit PO</label>` : ''}
//                 </div>
//             </div>
//         </div>
//     `;
//     return card;
// }
/**
 * NEW/REWRITTEN FUNCTION
 * Creates HTML fragments for a PO card and its associated modals.
 * @param {object} po - The purchase order data object.
 * @param {boolean} isSuperuser - Flag indicating if the current user is a superuser.
 * @param {Array} statusChoices - Array of [code, label] for status options.
 * @param {object} statusDates - Object mapping poId -> statusCode -> dateString.
 * @returns {object} An object like { cardHTMLFragment: DocumentFragment, modalsHTMLFragment: DocumentFragment }
 */
 function createPoCardAndModalHTMLFragments(po, isSuperuser, statusChoices = [], statusDates = {}) {
    const cardFragment = document.createDocumentFragment();
    const modalsFragment = document.createDocumentFragment();

    if (!po || typeof po.id === 'undefined') {
        console.warn("[createPoCardAndModalHTMLFragments] Invalid PO data received:", po);
        return { cardHTMLFragment: cardFragment, modalsHTMLFragment: modalsFragment };
    }

    console.log(`[createPoCardAndModalHTMLFragments] Creating card & modals for PO ID: ${po.id}, isSuperuser: ${isSuperuser}`);

    const supplierName = (po.supplier && typeof po.supplier.name === 'string') ? po.supplier.name : (typeof po.supplier === 'string' ? po.supplier : 'N/A');

    let itemsHtmlRows = '';
    if (po.items && Array.isArray(po.items) && po.items.length > 0) {
        itemsHtmlRows = po.items.map(item => {
            return item ? `
                <tr>
                    <td>${item.sku || 'N/A'}</td>
                    <td>${item.name || 'N/A'}</td>
                    <td>${item.quantity || 0}</td>
                    <td>${item.price || '0.00'}</td>
                    <td>${item.total_price || '0.00'}</td>
                </tr>
            ` : '';
        }).join('');
    } else {
        itemsHtmlRows = '<tr><td colspan="5" class="text-center py-2">No items in this purchase order.</td></tr>';
    }
     if (!itemsHtmlRows.trim()) {
        itemsHtmlRows = '<tr><td colspan="5" class="text-center py-2">Item data seems incomplete.</td></tr>';
    }


    let etaDateFormatted = formatCustomDateForETA(po.eta);
    const etaForInput = po.eta || '';
    let lastUpdatedFormatted = formatCustomDateTime(po.last_updated_date);

    // --- Create Card Element ---
    const cardDiv = document.createElement('div');
    cardDiv.id = `po-card-${po.id}`;
    cardDiv.className = 'bg-base-100 shadow rounded-xl p-4 relative mb-6 po-card';
    cardDiv.innerHTML = `
        <div class="absolute top-0 left-0 h-2 w-full rounded-t-xl ${getStatusStripeClasses(po.status || 'UNKNOWN')}"></div>
        <div class="flex justify-between items-start mt-4">
            <div>
                <h3 class="text-lg font-semibold">PO #${po.id} - ${supplierName}</h3>
                <p class="text-sm text-gray-500">ETA: ${etaDateFormatted}</p>
            </div>
            <div class="flex items-center gap-x-4">
                <span id="status-label-${po.id}" class="badge badge-lg py-5 font-semibold ${getStatusBadgeClasses(po.status || 'UNKNOWN')}">
                    ${po.status_display || po.status || 'Unknown Status'}
                </span>
                <label for="modal-update-po-${po.id}" class="btn btn-sm btn-outline">Update</label>
                ${(po.status === 'PARTIALLY_DELIVERED' || po.status === 'DELIVERED') ?
                `<label for="modal-receive-items" class="btn btn-sm btn-outline receive-items-trigger" data-po-id="${po.id}">Receive</label>`
                : ''
                }
            </div>
        </div>
        <div class="mt-4">
            <table class="table w-full table-sm">
                <thead><tr><th>SKU</th><th>Item</th><th>Qty</th><th>Unit Price</th><th>Total</th></tr></thead>
                <tbody>${itemsHtmlRows}</tbody>
            </table>
            <div class="flex justify-between items-center mt-4">
                <p class="text-sm text-gray-500">Last updated: ${lastUpdatedFormatted}</p>
                <div class="text-right font-bold">
                    Total Amount: ${po.total_amount || '0.00'}
                    ${isSuperuser ? `<label for="modal-edit-items-${po.id}" class="btn btn-sm btn-outline edit-po-action">Edit PO</label>` : ''}
                </div>
            </div>
        </div>
    `;
    cardFragment.appendChild(cardDiv);

    // --- Create Update PO Modal HTML ---
    const getPoStatusDate = (poIdForDate, statusCode) => {
        const poIdStr = String(poIdForDate);
        if (statusDates && statusDates[poIdStr] && statusDates[poIdStr][statusCode]) {
            try {
                const dateObj = new Date(statusDates[poIdStr][statusCode]);
                if (!isNaN(dateObj)) {
                    return dateObj.toLocaleString(undefined, { day: '2-digit', month: '2-digit', year: 'numeric', weekday: 'long', hour: '2-digit', minute: '2-digit' });
                }
            } catch (e) { /* ignore */ }
            return statusDates[poIdStr][statusCode]; // Fallback to raw if parse fails
        }
        return null;
    };
    console.log(`[createPoCardAndModalHTMLFragments] PO ID: ${po.id}, For Update Modal, statusChoices received:`, JSON.stringify(statusChoices));

    const updateModalButtonsHTML = statusChoices.map(([code, label]) => {
        const poIdStr = String(po.id);
        const poSpecificStatusDates = statusDates[poIdStr] || {};
        const rawDateString = poSpecificStatusDates[code];

        if (rawDateString) { // If a date string exists for this status
            const formattedDate = formatCustomDateTime(rawDateString); // Use the new helper
            return `
                <div class="space-y-1">
                    <button type="button" class="btn btn-md w-full btn-neutral" disabled>${label}</button>
                    <div class="text-md text-center text-gray-500">${formattedDate}</div>
                </div>`;
        } else { // No date string, so it's an actionable button
            return `
                <div class="space-y-1">
                    <button type="button" class="btn btn-md w-full status-select-btn btn-outline" data-po-id="${po.id}" data-status="${code}">${label}</button>
                </div>`;
        }
    }).join('');


    console.log(`[createPoCardAndModalHTMLFragments] PO ID: ${po.id}, For Update Modal, generated updateModalButtonsHTML:`, updateModalButtonsHTML);

    const updateModalInput = document.createElement('input');
    updateModalInput.type = 'checkbox';
    updateModalInput.id = `modal-update-po-${po.id}`;
    updateModalInput.className = 'modal-toggle po-specific-modal-toggle'; // Class for potential cleanup
    modalsFragment.appendChild(updateModalInput);

    const updateModalDiv = document.createElement('div');
    updateModalDiv.className = 'modal po-specific-modal-container'; // Class for potential cleanup
    updateModalDiv.setAttribute('role', 'dialog');
    updateModalDiv.innerHTML = `
        <div class="modal-box max-w-5xl" data-po-id="${po.id}">
            <h3 class="font-bold text-lg mb-4">Edit Purchase Order #${po.id}</h3>
            <form method="post" action="/warehouse/po/${po.id}/update/" class="po-update-form" data-po-id="${po.id}">
                <input type="hidden" name="csrfmiddlewaretoken" value="${getCsrfToken()}">
                <div class="form-control mb-4">
                    <label class="label font-bold">ETA</label>
                    <input type="date" name="eta" value="${etaForInput}" class="input input-bordered w-full" />
                </div>
                <h3 class="font-bold text-lg mb-4">Update PO Status</h3>
                <input type="hidden" name="selected_status" id="selected-status-${po.id}" value="${po.status || ''}">
                <div class="grid grid-cols-2 gap-4">
                    ${updateModalButtonsHTML}
                </div>
                <div class="modal-action mt-6">
                    <button type="submit" class="btn btn-primary">Save Changes</button>
                    <label for="modal-update-po-${po.id}" class="btn btn-outline">Cancel</label>
                </div>
            </form>
        </div>
    `;
    modalsFragment.appendChild(updateModalDiv);

    // --- Create Edit PO Modal HTML (if superuser) ---
    if (isSuperuser) {
        let editItemsTableRows = '';
        if (po.items && Array.isArray(po.items) && po.items.length > 0) {
            editItemsTableRows = po.items.map((item, index) => {
                return item ? `
                    <tr>
                        <input type="hidden" name="item_id_${index}" value="${item.po_item_id || item.id || ''}">
                        <input type="hidden" name="product_${index}" value="${item.item_id || item.product_id || ''}">
                        <td>${item.sku || 'N/A'}</td>
                        <td>${item.name || 'N/A'} ${item.warehouse_name ? '@ ' + item.warehouse_name : ''}</td>
                        <td><input type="number" name="quantity_${index}" value="${item.quantity || 0}" class="input input-sm input-bordered w-24" /></td>
                        <td><input type="number" step="0.01" name="price_${index}" value="${item.price || '0.00'}" class="input input-sm input-bordered w-24" /></td>
                    </tr>
                ` : '';
            }).join('');
        } else {
             editItemsTableRows = '<tr><td colspan="4" class="text-center py-2">No items to edit.</td></tr>';
        }
        if (!editItemsTableRows.trim()) {
            editItemsTableRows = '<tr><td colspan="4" class="text-center py-2">Item data for editing seems incomplete.</td></tr>';
        }


        const editModalInput = document.createElement('input');
        editModalInput.type = 'checkbox';
        editModalInput.id = `modal-edit-items-${po.id}`;
        editModalInput.className = 'modal-toggle po-specific-modal-toggle';
        modalsFragment.appendChild(editModalInput);

        const editModalDiv = document.createElement('div');
        editModalDiv.className = 'modal po-specific-modal-container';
        editModalDiv.setAttribute('role', 'dialog');
        editModalDiv.innerHTML = `
            <div class="modal-box max-w-3xl" data-po-id="${po.id}">
                <h3 class="font-bold text-lg mb-4">Edit Items for PO #${po.id}</h3>
                <form method="post" action="/warehouse/po/${po.id}/edit-items/" class="po-edit-form" data-po-id="${po.id}">
                    <input type="hidden" name="csrfmiddlewaretoken" value="${getCsrfToken()}">
                    <table class="table w-full mb-4" id="po-items-table-${po.id}">
                        <thead><tr><th>SKU</th><th>Product</th><th>Quantity</th><th>Unit Price</th></tr></thead>
                        <tbody>
                            ${editItemsTableRows}
                        </tbody>
                    </table>
                    <div class="modal-action justify-between">
                        <label for="modal-edit-items-${po.id}" class="btn">Cancel</label>
                        <div>
                            <button type="submit" class="btn btn-primary">Save Changes</button>
                            <button type="button" class="btn btn-error delete-po-btn" data-po-id="${po.id}">Delete PO</button>
                        </div>
                    </div>
                </form>
            </div>
        `;
        modalsFragment.appendChild(editModalDiv);
    }

    console.log(`[createPoCardAndModalHTMLFragments] PO ID: ${po.id}, Generated card querySelector '.text-right.font-bold' innerHTML:`, cardDiv.querySelector('.text-right.font-bold') ? cardDiv.querySelector('.text-right.font-bold').innerHTML : 'text-right div not found in cardHTML');

    return { cardHTMLFragment: cardFragment, modalsHTMLFragment: modalsFragment };
}

function updatePagination(poListContainer, data) {
    const paginationContainer = poListContainer.querySelector('.pagination');
    if (!paginationContainer) return;

    let paginationHTML = '';
    if (data.has_prev) {
        paginationHTML += `<a href="?page=${data.previous_page_number}" class="btn btn-sm pagination-link">¬´ Prev</a>`;
    }
    for (let i = 1; i <= data.total_pages; i++) {
        if (parseInt(data.page) === i) {
            paginationHTML += `<button class="btn btn-sm btn-primary pagination-link">${i}</button>`;
        } else {
            paginationHTML += `<a href="?page=${i}" class="btn btn-sm pagination-link">${i}</a>`;
        }
    }
    if (data.has_next) {
        paginationHTML += `<a href="?page=${data.next_page_number}" class="btn btn-sm pagination-link">Next ¬ª</a>`;
    }
    paginationContainer.innerHTML = paginationHTML;
}

function updatePaginationStates(jsonDataFromServer) {
    console.log("updatePaginationStates called with data:", jsonDataFromServer);
    if (jsonDataFromServer && jsonDataFromServer.page !== undefined) {
        pendingPOFilters.page = jsonDataFromServer.page.toString();
        console.log("pendingPOFilters.page updated by updatePaginationStates to:", pendingPOFilters.page);
    } else {
        // If page info isn't in jsonDataFromServer, it might be a sign that
        // the current view (like after delete) should reset to page 1 or use existing pendingPOFilters.page
        console.warn("updatePaginationStates: jsonDataFromServer or jsonDataFromServer.page is undefined. Current pendingPOFilters.page:", pendingPOFilters.page);
    }
    // Any other global pagination state variables you might want to update from jsonDataFromServer
    // (e.g., has_next, total_pages) can be handled here if needed by other parts of your JS.

    saveTabFiltersToSession('purchaseorders', pendingPOFilters); // Save updated state
}

function getStatusBadgeClasses(status) {
    switch (status) {
        case 'DRAFT': return 'bg-gray-400 text-white';
        case 'WAITING_INVOICE': return 'bg-yellow-400 text-black';
        case 'PAYMENT_MADE': return 'bg-blue-400 text-white';
        case 'PARTIALLY_DELIVERED': return 'bg-purple-400 text-white';
        case 'DELIVERED': return 'bg-green-500 text-white';
        case 'CANCELLED': return 'bg-red-400 text-white';
        default: return 'badge-ghost';
    }
}

function getStatusStripeClasses(status) {
    switch (status) {
        case 'DRAFT': return 'bg-gray-400';
        case 'WAITING_INVOICE': return 'bg-yellow-400';
        case 'PAYMENT_MADE': return 'bg-blue-400';
        case 'PARTIALLY_DELIVERED': return 'bg-purple-400';
        case 'DELIVERED': return 'bg-green-500';
        case 'CANCELLED': return 'bg-red-400';
        default: return 'bg-gray-200';
    }
}

function initLoadMorePOs() {
    console.log("Attempting to initialize Load More POs functionality...");
    // The button is expected to be a direct child of .load-more-button-container, which is a child of #purchase-orders-list
    const poListContainer = document.getElementById("purchase-orders-list");
    if (!poListContainer) {
        console.warn("initLoadMorePOs: #purchase-orders-list container not found.");
        return;
    }

    const exploreMoreBtnElement = poListContainer.querySelector('#explore-more-pos-btn');

    if (exploreMoreBtnElement) {
        console.log("Load More POs button (explore-more-pos-btn) found by initLoadMorePOs.");

        // Clone to remove previous listeners before adding a new one
        const newExploreMoreBtn = exploreMoreBtnElement.cloneNode(true);
        exploreMoreBtnElement.parentNode.replaceChild(newExploreMoreBtn, exploreMoreBtnElement);

        newExploreMoreBtn.addEventListener('click', () => {
            const currentPageFromState = (parseInt(pendingPOFilters.page, 10) || 1);
            const nextPageToFetch = currentPageFromState + 1;

            console.log(`Explore more POs clicked. Current last displayed page from state: ${currentPageFromState}. Fetching page: ${nextPageToFetch}`);

            let url = `/warehouse/po-load-more/?page=${nextPageToFetch}`;
            if (pendingPOFilters.q) url += `&q=${encodeURIComponent(pendingPOFilters.q)}`;
            if (pendingPOFilters.supplier) url += `&supplier=${pendingPOFilters.supplier}`;
            if (pendingPOFilters.status) url += `&status=${pendingPOFilters.status}`;

            newExploreMoreBtn.disabled = true;
            newExploreMoreBtn.innerHTML = '<span class="loading loading-spinner"></span> Loading...';

            fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
                .then(response => response.text())
                .then(html => {
                    // The button that was clicked (newExploreMoreBtn) and its container should be removed.
                    // The incoming 'html' (from _po_list_items.html) will contain the next set of items
                    // AND the next "Load More" button if applicable.
                    if (newExploreMoreBtn.parentNode) {
                        newExploreMoreBtn.parentNode.remove(); // Remove the container of the clicked button
                    }

                    const itemListContainer = document.getElementById('item-list-container');
                    if (itemListContainer) {
                        itemListContainer.insertAdjacentHTML('beforeend', html);
                    }

                    pendingPOFilters.page = nextPageToFetch.toString(); // Update current page
                    saveTabFiltersToSession('purchaseorders', pendingPOFilters);

                    // Re-initialize interactivity for newly added PO cards
                    if (itemListContainer) {
                       bindPOModalDirectInteractivity(itemListContainer);
                       initReceiveItemsModal(); // Specifically for elements within itemListContainer
                    }
                    // IMPORTANT: Call initLoadMorePOs again to find and attach listener to the *new* button
                    // if it was rendered within the newly added 'html'.
                    initLoadMorePOs();
                })
                .catch(error => {
                    console.error('Error loading more PO items:', error);
                    // Attempt to restore button if it wasn't removed or if error occurred before removal
                    const stillExistsButton = document.getElementById('explore-more-pos-btn');
                    if(stillExistsButton){
                        stillExistsButton.disabled = false;
                        stillExistsButton.innerHTML = 'Explore More';
                    }
                });
        });
    } else {
        console.log("Load More POs button (explore-more-pos-btn) NOT found by initLoadMorePOs at this time.");
    }
}




// ======= PurchaseOrder Modal UTILS =======
function submitUpdateForm(form, poId) {
  const formData = new FormData(form);
  const saveBtn = form.querySelector('button[type="submit"]');

  saveBtn.disabled = true;
  saveBtn.innerHTML = '<span class="loading loading-spinner"></span> Saving...';

  fetch(form.action, {
    method: "POST",
    headers: {
      "X-Requested-With": "XMLHttpRequest"
    },
    body: formData
  })
  .then(response => {
    if (!response.ok) throw new Error('Network response was not ok');
    return response.text();
  })
  .then(html => {
    const tabContent = document.getElementById("tab-content");
    tabContent.innerHTML = html;

    // ‚úÖ Âà∑Êñ∞ÂêéÔºåÂøÖÈ°ªÁ≠â requestAnimationFrame ÂÜçÊâßË°åinitPurchaseOrderTab
    requestAnimationFrame(() => {
      initPurchaseOrderTab();  // ÈáçÊñ∞ÁªëÂÆöÊâÄÊúâÂàÜÈ°µ„ÄÅ‰øùÂ≠òË°®Âçï„ÄÅmodalÈÄªËæëÔºÅ

      // ‚úÖ ÂÜç‰∏ã‰∏ÄÂ∏ßÊâßË°åÊªöÂä®
      requestAnimationFrame(() => {
        const updatedCard = document.getElementById(`po-card-${poId}`);
        if (updatedCard) {
          updatedCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          updatedCard.classList.add('po-highlight');
          setTimeout(() => {
            updatedCard.classList.add('po-highlight-fadeout'); // ËøáÊ∏°ÊàêÈÄèÊòé
          }, 1000); // Á≠âÈ´ò‰∫Æ‰∏Ä‰ºöÂÑø

          setTimeout(() => {
            updatedCard.classList.remove('po-highlight', 'po-highlight-fadeout'); // Ê∏ÖÈô§Âπ≤ÂáÄ
          }, 2000);
        }
      });
    });

    // ‚úÖ ÂÖ≥Èó≠ Modal
    const modalToggle = document.getElementById(`modal-${poId}`);
    if (modalToggle) {
      modalToggle.checked = false;
    }

    // ‚úÖ ÊàêÂäüToast
    Swal.fire({
      toast: true,
      position: 'top-end',
      icon: 'success',
      title: 'PO Updated!',
      showConfirmButton: false,
      timer: 1500
    });

  })
  .catch(error => {
    console.error('Error updating PO:', error);
    Swal.fire({
      icon: 'error',
      title: 'Update Failed',
      text: 'Please try again later.'
    });
  })
  .finally(() => {
    saveBtn.disabled = false;
    saveBtn.innerHTML = 'Save Changes';
  });
}

function initStatusButtons(poId) {
  console.log(`initStatusButtons called for PO#${poId}`);

  const hiddenInput = document.getElementById(`selected-status-${poId}`);
  if (!hiddenInput) return;

  // ÂàùÂßãÂåñÊó∂Ôºå‰∏çÈÄâ‰∏≠‰ªª‰ΩïÊåâÈíÆÔºåÊâÄÊúâ status-select-btn ‰øùÊåÅ btn-outline
  document.querySelectorAll(`.modal-box[data-po-id="${poId}"] .status-select-btn:not([disabled])`).forEach(button => {
    button.classList.remove('btn-neutral');
    button.classList.add('btn-outline');
  });

  // ÁÇπÂáªÊó∂ÔºåÂàáÊç¢È´ò‰∫Æ
  document.querySelectorAll(`.modal-box[data-po-id="${poId}"] .status-select-btn:not([disabled])`).forEach(button => {
    button.addEventListener('click', function() {
      hiddenInput.value = this.dataset.status;  // Êõ¥Êñ∞ÈöêËóèinputÁöÑÂÄº

      document.querySelectorAll(`.modal-box[data-po-id="${poId}"] .status-select-btn:not([disabled])`).forEach(btn => {
        btn.classList.remove('btn-neutral');
        btn.classList.add('btn-outline');
      });

      this.classList.remove('btn-outline');
      this.classList.add('btn-neutral');
    });
  });
}

function refreshPOAfterSave(poId, modalId = null, successMessage = "PO Updated!") {
  const currentParams = new URLSearchParams(window.location.search);
  const page = currentParams.get("page") || 1;

  currentParams.set("tab", "purchaseorders");
  currentParams.set("page", page);

  const reloadUrl = `?${currentParams.toString()}`;

  fetch(reloadUrl, {
    headers: { "X-Requested-With": "XMLHttpRequest" }
  })
    .then(res => res.text())
    .then(html => {
      document.getElementById("tab-content").innerHTML = html;
      requestAnimationFrame(() => {
        initPurchaseOrderTab();

        requestAnimationFrame(() => {
          const card = document.getElementById(`po-card-${poId}`);
          if (card) {
            card.scrollIntoView({ behavior: "smooth", block: "center" });
            card.classList.add("po-highlight");
            setTimeout(() => card.classList.add("po-highlight-fadeout"), 1000);
            setTimeout(() => card.classList.remove("po-highlight", "po-highlight-fadeout"), 2000);
          }
        });
      });

      if (modalId) closeModal(modalId);

      Swal.fire({
        toast: true,
        icon: "success",
        position: "top-end",
        title: successMessage,
        showConfirmButton: false,
        timer: 1500
      });
    });
}

function saveForm(form, poId, modalId = null, successMessage = "PO Saved!") {
  console.log(`[saveForm] Called for PO ID: ${poId}, Modal ID: ${modalId}`);
  console.log(`[saveForm] Form element:`, form);

  const saveBtn = form.querySelector('button[type="submit"]');
  const formData = new FormData(form);

  console.log(`[saveForm] FormData entries:`);
  for (let [key, value] of formData.entries()) {
        console.log(`  ${key}: ${value}`);
    }

  saveBtn.disabled = true;
  saveBtn.innerHTML = '<span class="loading loading-spinner"></span> Saving...';

  fetch(form.action, {
    method: "POST",
    headers: {
      "X-Requested-With": "XMLHttpRequest"
    },
    body: formData
  })
    .then(response => {
      if (!response.ok) throw new Error("Form submission failed");
      return response.text();  // È¢ÑÁïôÂèØÊâ©Â±ïÔºöÊú™Êù•ÂèØËß£Êûê JSON
    })
    .then(() => {
      refreshPOAfterSave(poId, modalId, successMessage);
    })
    .catch(error => {
      console.error("Error saving form:", error);
      Swal.fire({
        icon: "error",
        title: "Save Failed",
        text: "Please try again later."
      });
    })
    .finally(() => {
      saveBtn.disabled = false;
      saveBtn.innerHTML = "Save Changes";
    });
}

function deletePo(poId) {
    Swal.fire({
        title: 'Are you sure?',
        text: "This PO will be permanently deleted!",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#d33', // Red for delete
        cancelButtonColor: '#3085d6', // Blue for cancel
        confirmButtonText: 'Yes, delete it!'
    }).then((result) => {
        if (result.isConfirmed) {
            // Make sure the URL is correct for your Django setup
            const deleteUrl = `/warehouse/po/${poId}/delete/`;

            fetch(deleteUrl, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(), // Ensure getCsrfToken() is defined
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => {
                if (!response.ok) {
                    // Try to get error message from response if possible
                    return response.text().then(text => {
                        throw new Error(`Failed to delete PO (${response.status}): ${text || 'Server error'}`);
                    });
                }
                // Check if response has content, might be empty on success
                return response.text();
            })
            .then((responseText) => { // Optional: check response if needed
                console.log(`PO #${poId} deleted successfully.`);
                Swal.fire({
                    toast: true,
                    icon: 'success',
                    title: 'Deleted!',
                    text: 'Purchase Order has been deleted.',
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 1500
                });
                // Refresh the current PO list using the existing filters
                refreshPOList(); // <<< CORRECTED: Call refreshPOList
            })
            .catch(error => {
                console.error(`Error deleting PO #${poId}:`, error);
                Swal.fire({
                    icon: 'error',
                    title: 'Deletion Failed',
                    text: error.message || 'Could not delete the PO. Please try again.'
                });
            });
        }
    });
}

function getNowDatetimeStr() {
  const now = new Date();
  return now.getFullYear() + "-" +
         String(now.getMonth()+1).padStart(2,'0') + "-" +
         String(now.getDate()).padStart(2,'0') + " " +
         String(now.getHours()).padStart(2,'0') + ":" +
         String(now.getMinutes()).padStart(2,'0');
}







// =========================== CORE UTILS
function debounce(fn, delay = 300) {
  let timeoutId;
  const debounced = (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      fn(...args);
    }, delay);
  };
  debounced.cancel = () => {
    clearTimeout(timeoutId);
  };
  return debounced;
}

function closeModal(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) modal.checked = false;
}

// Modified getCsrfToken function to use the cached value
function getCsrfToken() {
    if (CSRF_TOKEN) {
        return CSRF_TOKEN;
    }
    // Fallback (less ideal if called after initial input might be gone)
    const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        console.warn("getCsrfToken: Had to re-query DOM for CSRF token.");
        return csrfInput.value;
    }
    console.error("getCsrfToken: CSRF Token is null and input field not found in DOM!");
    return ""; // Or handle error appropriately
}

// Add these helper functions in your <script> block

/**
 * Formats a date string (assumed to be ISO 8601 UTC) to "dd/mm/yyyy, DayOfWeek, HH:MM AM/PM".
 * @param {string} dateString - The ISO 8601 UTC date string (e.g., "2025-05-12T06:31:00Z").
 * @returns {string} The formatted date-time string or the original string if formatting fails.
 */
 function formatCustomDateTime(dateString) {
    if (!dateString) return 'N/A';
    try {
        const dateObj = new Date(dateString);
        if (isNaN(dateObj.getTime())) {
            console.warn('[JS] Invalid date string for formatCustomDateTime:', dateString);
            return dateString; // Fallback for invalid dates
        }

        // Get "dd/mm/yyyy" using en-GB
        const datePartOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };
        const formattedDate = dateObj.toLocaleDateString('en-GB', datePartOptions);

        // Get "DayOfWeek"
        const weekdayOptions = { weekday: 'long' };
        const formattedWeekday = dateObj.toLocaleDateString('en-GB', weekdayOptions); // Using en-GB for consistency, but weekday is often similar across locales

        // Get "HH:MM AM/PM"
        const timeOptions = { hour: '2-digit', minute: '2-digit', hour12: true };
        const formattedTime = dateObj.toLocaleTimeString('en-US', timeOptions); // Using 'en-US' for a common hh:mm AM/PM format, adjust if needed

        return `${formattedDate}, ${formattedWeekday}, ${formattedTime}`;

    } catch (e) {
        console.warn(`[JS] Could not parse or format date-time:`, dateString, e);
        return dateString; // Fallback to original string
    }
}


/**
 * Formats a date string (YYYY-MM-DD) to "dd/mm/yyyy, DayOfWeek" for ETA.
 * @param {string} dateOnlyString - The date string in YYYY-MM-DD format (e.g., "2025-05-13").
 * @returns {string} The formatted date string or the original string if formatting fails.
 */
 function formatCustomDateForETA(yyyyMmDdString) {
    if (!yyyyMmDdString) return 'N/A'; // Handle null or empty input
    try {
        const parts = yyyyMmDdString.split('-');
        if (parts.length !== 3) {
            console.warn('[JS] Invalid YYYY-MM-DD format for ETA:', yyyyMmDdString);
            return yyyyMmDdString; // Return original if not YYYY-MM-DD
        }

        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // JavaScript months are 0-indexed (0-11)
        const day = parseInt(parts[2], 10);

        // Create a Date object representing midnight in the local timezone for that specific date
        const dateObj = new Date(year, month, day);

        if (isNaN(dateObj.getTime())) { // Check if the constructed date is valid
            console.warn('[JS] Invalid date constructed for formatCustomDateForETA:', yyyyMmDdString);
            return yyyyMmDdString; // Fallback for invalid dates
        }

        // Get "dd/mm/yyyy" using 'en-GB' locale option
        const datePartOptions = { day: '2-digit', month: '2-digit', year: 'numeric' };
        const formattedDate = dateObj.toLocaleDateString('en-GB', datePartOptions);

        // Get "DayOfWeek" (e.g., "Tuesday")
        const weekdayOptions = { weekday: 'long' };
        const formattedWeekday = dateObj.toLocaleDateString('en-GB', weekdayOptions); // 'en-GB' for consistency, but weekday name is usually fine

        return `${formattedDate}, ${formattedWeekday}`; // "dd/mm/yyyy, DayOfWeek"

    } catch (e) {
        console.warn(`[JS] Error formatting ETA date:`, yyyyMmDdString, e);
        return yyyyMmDdString; // Fallback to original string in case of error
    }
}




// =========================== TAB ROUTER INIT
function initTabs() {
    console.log("‚úÖ initTabs initialized (v4)");
    const tabLinks = document.querySelectorAll(".tabs a[data-tab]");

    tabLinks.forEach(tabLink => {
        tabLink.addEventListener("click", function (e) {
            e.preventDefault();
            const targetTabName = this.dataset.tab;
            const currentActiveTab = getCurrentTabNameFromUrl();

            if (currentActiveTab && currentActiveTab !== targetTabName) {
                let stateToSaveOnClick = {};
                if (currentActiveTab === 'purchaseorders') stateToSaveOnClick = pendingPOFilters;
                else if (currentActiveTab === 'warehouseproduct') stateToSaveOnClick = window.currentWarehouseFilters;
                saveTabFiltersToSession(currentActiveTab, stateToSaveOnClick);
            }

            const paramsFromSession = loadTabFiltersFromSession(targetTabName);
            paramsFromSession.set("tab", targetTabName);
            if ((TAB_SPECIFIC_PARAMS[targetTabName] || []).includes('page') && !paramsFromSession.has('page') && paramsFromSession.toString() !== `tab=${targetTabName}`) {
                // Add page=1 if other filters are loaded from session for this tab but page is missing
                // paramsFromSession.set('page', '1');
            }


            const finalUrl = `?${paramsFromSession.toString()}`;
            console.log(`Navigating to tab ${targetTabName} with URL: ${finalUrl}`);
            history.pushState({ path: finalUrl, tab: targetTabName }, '', finalUrl);

            fetch(finalUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
                .then(res => {
                    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}, fetching ${finalUrl}`);
                    return res.text();
                })
                .then(html => {
                    const tabContentEl = document.getElementById("tab-content");
                    if (tabContentEl) tabContentEl.innerHTML = html;
                    else return console.error("#tab-content element not found.");
                    highlightActiveTabFromURL();
                    requestAnimationFrame(() => {
                        if (targetTabName === "purchaseorders") initPurchaseOrderTab();
                        else if (targetTabName === "warehouseproduct") initWarehouseTab();
                    });
                })
                .catch(error => console.error("Failed to load tab content:", error));
        });
    });
}

function getCurrentTabNameFromUrl() {
    return new URLSearchParams(window.location.search).get("tab") || DEFAULT_TAB;
}
function saveTabFiltersToSession(tabName, filterStateToSave) {
    const paramsForStorage = new URLSearchParams();
    const allowedParams = TAB_SPECIFIC_PARAMS[tabName] || [];

    if (!filterStateToSave) {
        console.warn(`üíæ Attempted to save null/undefined filter state for ${tabName}. Saving empty.`);
        sessionStorage.setItem(`tabParams_${tabName}`, "");
        return;
    }

    const sourceParams = (filterStateToSave instanceof URLSearchParams) ? filterStateToSave : new URLSearchParams(filterStateToSave);

    allowedParams.forEach(key => {
        if (sourceParams.has(key) && sourceParams.get(key)) {
            paramsForStorage.set(key, sourceParams.get(key));
        }
    });

    // Handle 'page' specifically: only save if it's > 1 or if other filters are present.
    // This avoids saving "page=1" for a truly empty/reset filter state.
    if (allowedParams.includes('page')) {
        const pageValue = sourceParams.get('page');
        if (pageValue && (paramsForStorage.toString().replace(`page=${pageValue}`, '').replace(/^&|&$/, '') || parseInt(pageValue) > 1) ) {
            // If other filters exist (excluding page itself) OR page > 1, then include page.
             if (!paramsForStorage.has('page')) paramsForStorage.set('page', pageValue);
        } else {
            paramsForStorage.delete('page'); // Don't save page=1 if no other filters
        }
    }

    const paramsString = paramsForStorage.toString();
    console.log(`üíæ Saving params for ${tabName}: "${paramsString}" (Source: object)`);
    sessionStorage.setItem(`tabParams_${tabName}`, paramsString);
}
function loadTabFiltersFromSession(tabName) {
    const storedParamsString = sessionStorage.getItem(`tabParams_${tabName}`);
    console.log(`üíæ Loading params for ${tabName} from session: "${storedParamsString}"`);
    return new URLSearchParams(storedParamsString || '');
}
function clearTabFiltersFromSession(tabName) {
    console.log(`üóëÔ∏è Clearing session storage for tab: ${tabName}`);
    sessionStorage.removeItem(`tabParams_${tabName}`);
}
function clearAllTabFiltersFromSession() {
    console.log(`üóëÔ∏è Clearing session storage for ALL tabs.`);
    for (const tabName in TAB_SPECIFIC_PARAMS) {
        sessionStorage.removeItem(`tabParams_${tabName}`);
    }
}

function getActiveTab() {
  const params = new URLSearchParams(window.location.search);
  return params.get("tab") || "warehouseproduct";
}

function runTabInit(tabName) {
  if (!tabInitStatus[tabName]) {
    tabInitStatus[tabName] = true;
    TAB_INIT_MAP[tabName]?.();
  }
}

function storeTabParams(tabName, params) {
  sessionStorage.setItem(`tab_params_${tabName}`, params.toString());
}

function getStoredTabParams(tabName) {
  const stored = sessionStorage.getItem(`tab_params_${tabName}`);
  return stored ? new URLSearchParams(stored) : null;
}

function loadTab(tabName, customParams = null, reset = false) {
  const cleanParams = new URLSearchParams();
  cleanParams.set("tab", tabName);

  const allowedKeys = TAB_PARAM_KEYS[tabName] || [];

  let paramsToUse;
  if (reset) {
    paramsToUse = new URLSearchParams();
    allowedKeys.forEach(k => paramsToUse.set(k, ""));
  } else if (customParams) {
    paramsToUse = new URLSearchParams(customParams);
  } else {
    const stored = getStoredTabParams(tabName);
    paramsToUse = stored || new URLSearchParams();
  }

  // Clear irrelevant params
  const allParamKeys = ["warehouse", "supplier", "q", "status", "page"]; // ALL possible params
  allParamKeys.forEach(key => {
    if (!allowedKeys.includes(key)) {
      paramsToUse.delete(key);
    }
  });

  // Ê∏ÖÈô§ÈùûËØ• tab ÁöÑÊó†ÂÖ≥ÂèÇÊï∞
  allowedKeys.forEach(k => {
    const v = paramsToUse.get(k);
    if (v !== null) cleanParams.set(k, v);
  });

  const finalUrl = `?${cleanParams.toString()}`;
  storeTabParams(tabName, cleanParams);

  history.pushState(null, '', finalUrl);

  fetch(finalUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
    .then(res => res.text())
    .then(html => {
      const container = document.getElementById("tab-content");
      container.innerHTML = html;
      highlightActiveTabFromURL();

      // Ê∏ÖÈô§ÊóßÁöÑ init Áä∂ÊÄÅÔºàÊØèÊ¨°Âä†ËΩΩ HTML ÂêéÂøÖÈ°ªÔºâ
      Object.keys(tabInitStatus).forEach(k => tabInitStatus[k] = false);
      highlightActiveTabFromURL();

      requestAnimationFrame(() => runTabInit(tabName));
    });
}

function highlightActiveTabFromURL() {
  const activeTab = getActiveTab();

  document.querySelectorAll('.tabs a').forEach(tab => {
    const tabUrl = new URL(tab.getAttribute("href"), window.location.origin);
    const tabParam = new URLSearchParams(tabUrl.search).get("tab") || "warehouseproduct";

    const activeClasses = ['bg-blue-500', 'text-white'];
    const inactiveClasses = ['bg-gray-200', 'text-gray-700', 'hover:bg-gray-300'];

    if (tabParam === activeTab) {
      tab.classList.remove(...inactiveClasses);
      tab.classList.add(...activeClasses);
    } else {
      tab.classList.remove(...activeClasses);
      tab.classList.add(...inactiveClasses);
    }
  });
}

// // =========================== load more
// const exploreMoreBtnForPagination = document.querySelector('#explore-more-pos-btn'); // Correctly select by ID
// const paginationContainer = exploreMoreBtnForPagination ? exploreMoreBtnForPagination.parentNode : null;
// let currentPage = 1; // Default current page value
// if (paginationContainer && paginationContainer.dataset && paginationContainer.dataset.nextPage) {
//     currentPage = parseInt(paginationContainer.dataset.nextPage, 10);
// } else {
//     if (!exploreMoreBtnForPagination) {
//         console.warn("Button with ID 'explore-more-pos-btn' not found. Load more functionality might be affected.");
//     } else {
//         console.warn("'data-next-page' attribute not found on the parent of '#explore-more-pos-btn'. Defaulting currentPage to 1. Load more functionality might be affected.");
//     }
// }

// const exploreMoreBtn = document.getElementById('explore-more-pos-btn');
// const itemListContainer = document.getElementById('item-list-container');

// if (exploreMoreBtn) {
//     exploreMoreBtn.addEventListener('click', () => {
//         const currentTab = getActiveTab();
//         let url = `?tab=<span class="math-inline">\{currentTab\}&page\=</span>{currentPage}`;
//         const currentFilters = getCurrentTabFilters(currentTab);
//         if (currentFilters) {
//             url += '&' + new URLSearchParams(currentFilters).toString();
//         }

//         fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
//             .then(response => response.text())
//             .then(html => {
//                 itemListContainer.insertAdjacentHTML('beforeend', html);
//                 currentPage++;
//                 paginationContainer.dataset.nextPage = currentPage; // Update the data attribute
//                 // ... (Update button visibility if needed) ...
//             })
//             .catch(error => console.error('Error loading more items:', error));
//     });
// }


function getCurrentTabFilters(tabName) {
    if (tabName === 'warehouseproduct') return window.currentWarehouseFilters;
    if (tabName === 'purchaseorders') return pendingPOFilters;
    return null;
}




// =========================== BOOTSTRAP
let CSRF_TOKEN = null;

// DOMContentLoaded ÂàùÂßãÂåñ
document.addEventListener("DOMContentLoaded", function () {
  // Cache the CSRF token once the initial DOM is loaded
  const csrfInput = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        CSRF_TOKEN = csrfInput.value;
        console.log("CSRF Token cached on DOMContentLoaded:", CSRF_TOKEN ? 'OK' : 'NOT FOUND');
    } else {
        console.error("CSRF Token input field not found on DOMContentLoaded!");
    }

  initTabs();
    let initialTabName = getCurrentTabNameFromUrl();
    let paramsForInitialLoad = new URLSearchParams(window.location.search);

    if (!window.location.search || window.location.search === "?") {
        console.log("Navigated to base URL. Clearing all tab session storages and loading default tab.");
        clearAllTabFiltersFromSession();
        initialTabName = DEFAULT_TAB;
        paramsForInitialLoad = new URLSearchParams();
        paramsForInitialLoad.set("tab", initialTabName);
    } else {
        console.log(`Initial load with URL params: "${paramsForInitialLoad.toString()}" for tab "${initialTabName}"`);
    }

    const finalInitialUrl = `?${paramsForInitialLoad.toString()}`;
    console.log(`Final initial URL for page load: ${finalInitialUrl}`);
    history.replaceState({ path: finalInitialUrl, tab: initialTabName }, '', finalInitialUrl);

    fetch(finalInitialUrl, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
        .then(res => {
             if (!res.ok) throw new Error(`HTTP error! status: ${res.status}, fetching ${finalInitialUrl}`);
             return res.text();
        })
        .then(html => {
            document.getElementById("tab-content").innerHTML = html;
            highlightActiveTabFromURL();
            requestAnimationFrame(() => {
                if (initialTabName === "purchaseorders") {
                    initPurchaseOrderTab();
                } else {
                    initWarehouseTab();
                }
            });
        })
        .catch(error => console.error("Error loading initial tab:", error));
});


</script>
{% endblock %}
